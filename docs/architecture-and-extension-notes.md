# Nasuni MCP Desktop Server – Architecture & Extension Notes

## Project Purpose
The repository packages a Model Context Protocol (MCP) server that lets desktop MCP clients—Claude Desktop, Cursor, or other compatible tools—browse an already-mounted Nasuni SMB share. The server exposes read-only browsing and retrieval utilities while enforcing configurable size and folder-access limits so the agent cannot wander outside the authorised subtree.

## Key Components
- **`mcp/server.py` (entry point)** – Instantiates a `FastMCP` server named `Nasuni File Storage Server`, initialises configuration/logging, and registers six MCP tools. Tool handlers delegate all filesystem work to the shared `FileSystem` instance.
- **`app/config.py` (`Config`)** – Loads environment variables (optionally `.env`) and CLI arguments such as `--exclude_folders`, providing defaults for scan limits, size ceilings, and logging. Environment values override defaults; CLI arguments override both.
- **`app/__init__.py` (`init_logger`, `get_file_system_client`)** – Configures a named logger, optionally writing to a user-specified file, and ensures `FILE_SYSTEM_PATH` is present before returning the `FileSystem` facade.
- **`app/file_system.py` (`FileSystem`)** – Wraps all local I/O, joining user-supplied relative paths against `FILE_SYSTEM_PATH`, rejecting traversal outside the root, respecting exclusion lists, and enforcing size limits. Supplies folder listings, metadata, byte/string reads, and image helpers.
- **`app/models.py` (Pydantic models)** – Shapes responses sent to MCP clients. `FileItem` precomputes booleans such as `is_supported_image` and `supports_text_extraction`; `FolderContents` separates files from subfolders and flags oversized items.
- **`app/utils.py` (helpers)** – Performs PDF/DOCX text extraction (`pypdf`, `python-docx`), builds image thumbnails (`Pillow`), and re-checks payload sizes prior to returning processed data.
- **Packaging assets** – `manifest.json` defines the DXT bundle and user prompts; `build_dxt.sh` automates packaging; `pyproject.toml` pins runtime dependencies. `scripts/process_traffic.py` is a GitHub analytics helper, unrelated to runtime.

## Request Lifecycle
1. **Startup**
   - `Config()` reads environment (`FILE_SYSTEM_PATH`, size settings, etc.), merges CLI flags, and normalises `exclude_folders`.
   - `init_logger()` sets up logging (silent by default unless `LOG_DESTINATION` or an explicit `LOG_LEVEL` is provided).
   - `get_file_system_client()` validates `FILE_SYSTEM_PATH` and returns a `FileSystem` instance.
   - `FastMCP` registers thin tool wrappers that call into `FileSystem`.
2. **Tool handling**
   - `_build_path()` joins the relative request path with `FILE_SYSTEM_PATH`, resolves it to an absolute path, and rejects any request whose common path diverges from the configured root.
   - `_require_path_is_in_excluded_folder()` and `_check_path_is_in_excluded_folder()` stop access to explicitly blocked directories.
   - `_check_file_size_is_not_too_large()` and `verify_length_is_not_too_large_to_return()` enforce `max_read_file_size` and `max_return_file_size` at both read and response phases.
   - Handler specifics:
     - `folder_contents` uses `os.scandir` with an item cap (`max_scan_items`).
     - `file_metadata` uses `hachoir` to enrich metadata; directories raise `ValueError`.
     - `file_contents` / `file_contents_base64` read raw data (text or bytes) while honouring size caps.
     - `image_file_contents` validates extension, optionally resizes, and returns an `Image` payload for MCP clients.
     - `file_file_contents_as_text` extracts text when the file is PDF/DOCX; other formats fall back to UTF-8 decoding with replacement.
3. **Error signalling**
   - Attempts to traverse outside the root, read excluded folders, or exceed size limits raise `ValueError`, which propagates to the MCP client.

## Configuration Surface
All settings map to environment variables (and are surfaced to users in `manifest.json` prompts):

| Setting | Purpose | Default (code) | Notes |
| --- | --- | --- | --- |
| `FILE_SYSTEM_PATH` | Root mount of the Nasuni share | _required_ | Must point to an already-mounted SMB path. |
| `MAX_SCAN_ITEMS` | Max entries listed per folder | `10000` (`Config`) | DXT manifest defaults to `1000`. |
| `MAX_RETURN_FILE_SIZE` | Largest payload returned | `1_048_576` bytes | Checked before returning raw data or processed results. |
| `MAX_READ_FILE_SIZE` | Largest file read from disk | `20_971_520` bytes | Allows larger reads when downsampling (e.g., thumbnails). |
| `EXCLUDE_FOLDERS` | Folder deny-list | `[]` | Normalised to drop trailing slashes. |
| `LOG_DESTINATION` / `LOG_LEVEL` | Logging | empty / `NOTSET` | File logging only if a destination is provided. |

Precedence: defaults → `.env` (if supplied) → environment variables → CLI arguments generated by the DXT manifest.

## Security and Operational Guardrails
- **Path sandboxing** – `_build_path()` uses absolute resolution plus `os.path.commonpath` to prevent directory traversal.
- **Exclusion enforcement** – Every operation checks against `exclude_folders`, blocking sensitive directories.
- **Size ceilings** – Distinguishes between read-size and return-size limits to balance safety and functionality.
- **Minimal logging by default** – Avoids accidental leakage into log files unless explicitly enabled.
- **Read-only semantics** – No write/delete operations exist; the server only enumerates and reads content.

## Exposed MCP Tools
- `folder_contents(path="") -> FolderContents`
- `file_metadata(path) -> FileMetadata`
- `file_contents(path) -> str`
- `file_contents_base64(path) -> str`
- `image_file_contents(path, thumb_width=0) -> Image`
- `file_file_contents_as_text(path) -> str`

All paths are relative to `FILE_SYSTEM_PATH` and use `/` separators, making the interface platform-neutral for MCP clients.

## Current Limitations
- Operates only on the _live_ mounted view of a Nasuni volume; no awareness of historical versions or snapshots.
- Requires the share to be mounted locally—there is no direct API connectivity or authentication workflow.
- Metadata extraction depends on `hachoir` parsing success; opaque/binary formats may yield minimal metadata.
- Text extraction supports only PDF/DOCX; other formats fall back to raw text decoding.

## Extension Outline: Version-Aware Navigation
To support browsing historical versions of files and folders within a Nasuni volume:

1. **Surface version sources**  
   - Integrate Nasuni’s snapshot/version APIs (REST) or CLI utilities (e.g., `nucli`), retrieving available snapshots for a volume and per-file version histories.  
   - Extend configuration with Nasuni appliance endpoints, credentials, target volume IDs, and optional feature toggles (e.g., enable_versioning).

2. **Model enhancements**  
   - Introduce version-aware models (e.g., `VersionedFileItem`, `FileVersion`) capturing identifiers, timestamps, size, and status (current, previous, deleted).  
   - Annotate existing models with `latest_version_id` or embed a `versions` list when requested.

3. **Filesystem abstraction**  
   - Add a service layer (e.g., `NasuniVersionService`) responsible for orchestrating API calls, caching snapshot listings, translating responses into local model shapes, and mapping version selections back to temporary retrieval URLs or mounted snapshot paths.
   - Introduce helpers for building synthetic paths such as `/@snapshots/{snapshot_id}/path/to/file` to keep MCP clients stateless while differentiating historical content.

4. **New MCP tools**  
   - `list_versions(path)` → returns available snapshots/version IDs for a file or folder.  
   - `get_version_metadata(path, version_id)` → extends metadata to include version timestamp, author, etc.  
   - `get_version_contents(path, version_id, as_base64=False)` → retrieves a specific historical payload, still honouring size caps.  
   - Consider `folder_contents(path, snapshot_id=None)` to allow browsing a historical directory tree.

5. **Safety controls**  
   - Reuse `exclude_folders`, size limits, and path sandboxing logic for versioned paths.  
   - Apply rate limiting or caching to avoid excessive calls to Nasuni APIs.

6. **Client experience**  
   - Document the new tools and provide examples (e.g., “show me the versions of `/projects/design.docx` from last week”).  
   - Clearly differentiate between live and versioned paths in responses so MCP agents can surface the context to users.

Implementing the above will provide time-travel navigation while maintaining the current secure, read-only design ethos.

## Snapshot-Based Implementation Plan (Local `.snapshot` Trees)
Many Nasuni desktop mounts expose historical versions through a hidden `.snapshot/` directory colocated with the live folder. For example, the sample volume at `/Users/jcapello/Desktop/UnifyDemo/AlfaDesign` contains:

```
.snapshot/
  2025_11_5_15.23GMT/
  2025_11_7_19.44GMT/
  2025_11_9_14.12GMT/
```

Each timestamped folder replicates the live directory structure, allowing “point-in-time” reads without hitting a remote API. To leverage this structure:

- **Configuration additions**  
  - `SNAPSHOT_FOLDER_NAME` (default `.snapshot`) – lets users rename or disable the feature.  
  - `INCLUDE_SNAPSHOT_ROOT` (bool, default `false`) – controls whether `.snapshot` appears in standard `folder_contents` results.

- **Path resolution**  
  - Introduce a `_build_snapshot_path(snapshot_id, relative_path)` helper that joins `file_system_path`, `SNAPSHOT_FOLDER_NAME`, the snapshot identifier, and the user path, reusing the existing sandboxing and exclusion checks.
  - Validate that the computed snapshot path exists; otherwise return 404-style errors.

- **New MCP tools (backed by local snapshots)**  
  - `list_snapshots(path: str = "") -> SnapshotList` – Enumerates available snapshots (`.snapshot/*`) and reports whether the requested file/folder exists in each. Uses directory timestamps (parse from folder name) for display ordering.  
  - `folder_contents(path: str = "", snapshot_id: str | None = None)` – Extend the existing tool to accept an optional `snapshot_id` parameter; when present, resolve paths within the snapshot tree.  
  - `file_metadata(path: str, snapshot_id: str | None = None)` and `file_contents` variants – Mirror live behaviour but source data from the chosen snapshot folder.  
  - `get_version_contents(path: str, snapshot_id: str, encoding: Literal["text","base64"]="text")` – Dedicated helper that wraps the existing `get_file_content_[...]` methods with snapshot-aware path resolution.

- **Models**  
  - Add `SnapshotSummary` (id, display_name, timestamp) and `FileVersion` (snapshot_id, modified_time, size).  
  - Extend responses to include `versions: list[FileVersion]` when a file has history.

- **Safety considerations**  
  - Treat snapshot data as read-only and still enforce `exclude_folders` by applying the same rules to the resolved absolute snapshot path.  
  - Honour `max_read_file_size`/`max_return_file_size` uniformly—snapshots often store large archives.

- **Client experience**  
  - Document sample commands: e.g., ask `list_snapshots("DesignSpec.docx")`, then fetch `file_contents("DesignSpec.docx", snapshot_id="2025_11_7_19.44GMT")`.  
  - Preserve forward compatibility with future API-based versioning; snapshot-aware tooling can share interfaces with remote implementations.

This approach enables immediate version navigation on desktops where Nasuni exposes `.snapshot` trees, without requiring additional infrastructure.


